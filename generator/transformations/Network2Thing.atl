-- @atlcompiler emftvm
-- @nsURI ThingML=http://www.thingml.org/xtext/ThingML
-- @nsURI CyprIoT=http://www.atlanmod.org/CyprIoT


module Network2Thing;

create OUT: ThingML from TH: ThingML, CY : CyprIoT;

-- Helpers

helper context String def : replaceDotsWithSlashInDomain() : String =
	self.replace('.', '/')
;

helper context String def : removeHash() : String =
	self.replaceAll('#', '')
;

helper context String def : transformArrowToMQTTSyntax : String =
	if self.startsWith('=>')
		then 'mqtt_publish_topic'
	else 
		'mqtt_subscribe_topic'
	endif
;

-- /BEGIN COPIER

rule copyThingMLModel {
	from s : ThingML!ThingMLModel
	to t : ThingML!ThingMLModel(
		configs <- s.configs->union(CyprIoT!Bind.allInstances()->select(e | e.bindsInstanceThing.typeThing.thingToInstantiate.name=s.types.first().name)), -- Implicit transformation mechanism
		imports <- s.imports,
		protocols <- s.protocols->union(CyprIoT!InstancePubSub.allInstances()), -- Implicit transformation mechanism
		types <- s.types
	)	
}

rule copyProtocol {
	from s : ThingML!Protocol
	to t : ThingML!Protocol(
		annotations <- s.annotations,
		name <- s.name
	)
}

rule copyThing {
	from s : ThingML!Thing
	to t : ThingML!Thing(
		name <- s.name,
		ports <- s.ports,
		annotations <- s.annotations,
		assign <- s.assign,
		behaviour <- s.behaviour,
		fragment <- s.fragment,
		functions <- s.functions,
		messages <- s.messages,
		includes <- s.includes,
		properties <- s.properties
	)
}

rule copyMessage {
	from s: ThingML!Message
	to t : ThingML!Message(
		name <- s.name,
		parameters <- s.parameters,
		annotations <- s.annotations
	)
}

rule copyProvidedPort {
	from s : ThingML!ProvidedPort
	to t : ThingML!ProvidedPort(
		name <- s.name,
		receives <- s.receives,
		sends <- s.sends,
		annotations <- s.annotations
	)
}

rule copyParameter {
	from s : ThingML!Parameter
	to t : ThingML!Parameter(
		annotations <- s.annotations,
		name <- s.name,
		typeRef <- s.typeRef
	)
}

rule copyTypeRef {
	from s : ThingML!TypeRef
	to t : ThingML!TypeRef(
		cardinality <- s.cardinality,
		isArray <- s.isArray,
		type <- s.type
	)
}

rule copyRequiredPort {
	from s : ThingML!RequiredPort
	to t : ThingML!RequiredPort(
		name <- s.name,
		receives <- s.receives,
		sends <- s.sends,
		annotations <- s.annotations
	)
}

rule copyCompositeState {
	from s : ThingML!CompositeState
	to t : ThingML!CompositeState(
		name <- s.name,
		annotations <- s.annotations,
		entry <- s.entry,
		exit <- s.exit,
		history <- s.history,
		initial <- s.initial,
		internal <- s.internal,
		outgoing <- s.outgoing,
		properties <- s.properties,
		region <- s.region,
		session <- s.session,
		substate <- s.substate
	)
}

rule copyFinalState {
	from s : ThingML!FinalState
	to t : ThingML!FinalState(
		name <- s.name,
		annotations <- s.annotations,
		entry <- s.entry,
		exit <- s.exit,
		internal <- s.internal,
		outgoing <- s.outgoing,
		properties <- s.properties
	)
}

rule copyActionBlock {
	from s : ThingML!ActionBlock
	to t : ThingML!ActionBlock(
		actions <- s.actions
	)
}

rule copyPrintAction {
	from s : ThingML!PrintAction
	to t : ThingML!PrintAction(
		line <- s.line,
		msg <- s.msg
	)
}

rule copySendAction {
	from s : ThingML!SendAction
	to t : ThingML!SendAction(
		message <- s.message,
		parameters <- s.parameters,
		port <- s.port
	)
}
rule copyIntegerLiteral {
	from s : ThingML!IntegerLiteral
	to t : ThingML!IntegerLiteral(
		intValue <- s.intValue
	)
}

rule copyPlatformAnnotation {
	from s : ThingML!PlatformAnnotation
	to t : ThingML!PlatformAnnotation(
		name <- s.name,
		value <- s.value
	)
}

rule copyStringLiteral {
	from s : ThingML!StringLiteral
	to t : ThingML!StringLiteral(
		stringValue <- s.stringValue
	)
}

rule copyInstance {
	from s : ThingML!Instance
	to t : ThingML!Instance(
		name <- s.name,
		type <- s.type,
		annotations <- s.annotations
	)
}

rule copyConfig {
	from s : ThingML!Configuration
	to t : ThingML!Configuration(
		annotations <- s.annotations,
		connectors <- s.connectors,
		instances <- s.instances,
		name <- s.name,
		propassigns <- s.propassigns
	)
}

rule copyDatatypes {
	from s : ThingML!PrimitiveType
	to t : ThingML!PrimitiveType(
		ByteSize <- s.ByteSize,
		annotations <- s.annotations,
		name <- s.name
	) 
}

-- COPIER / END


rule createExternalConnectorFromBind {
	from s : CyprIoT!Bind((ThingML!Port.allInstances().first().refImmediateComposite()->refGetValue('name')=s.bindsInstanceThing.typeThing.thingToInstantiate.name))
	to 
	c : ThingML!Configuration(
		name <- s.bindsInstanceThing.typeThing.thingToInstantiate.name+'_Cfg',
		instances <- Sequence{i},
		connectors <- Sequence{t}
	),
	i : ThingML!Instance(
		name <- s.bindsInstanceThing.name,
		type <- ThingML!Thing.allInstances().first() -- TODO : more generic
	),
	a : ThingML!PlatformAnnotation(
		name <- s.bindAction.toString().removeHash().transformArrowToMQTTSyntax,
		value <- s.refImmediateComposite()->refGetValue('domain')->refGetValue('name').toString().replaceDotsWithSlashInDomain()+'/'+s.channelToBind->refGetValue('topics')->refInvokeOperation('get', Sequence{0})->refGetValue('name').toString()
	),
	t : ThingML!ExternalConnector(
		inst <- i,
		port <- ThingML!Port.allInstances().first(),
		protocol <- CyprIoT!InstancePubSub.allInstances().first(),
		annotations <- Sequence{a}
	)
}


rule transformProtocol {
	from s : CyprIoT!InstancePubSub
	to t : ThingML!Protocol(
		name <- s.typePubSub.targetedProtocol.toString().removeHash(),
		annotations <- Sequence{a1,a2,a3}
	),
	a1 : ThingML!PlatformAnnotation(
		name <- 'mqtt_broker_address',
		value <- s.typePubSub.server.toString().split(':').first()
	),
	a2 : ThingML!PlatformAnnotation(
		name <- 'mqtt_port_number',
		value <- s.typePubSub.server.toString().split(':').last()
	),
	a3 : ThingML!PlatformAnnotation(
		name <- 'serializer',
		value <- 'JSON'
	)
}
