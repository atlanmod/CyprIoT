-- @atlcompiler emftvm
-- @nsURI ThingML=http://www.thingml.org/xtext/ThingML
-- @nsURI CyprIoT=http://www.atlanmod.org/CyprIoT


module RuleTrigger;

create OUT: ThingML from TH: ThingML, CY : CyprIoT;

uses Copier;
uses Helpers;

-- Get the network to make (support for first network only for the moment)
helper def : firstNetwork() : CyprIoT!Network = CyprIoT!Network.allInstances().first();

helper context CyprIoT!Network def : collectEnforcedPoliciesInNetwork() : Sequence(CyprIoT!Policy) = self.hasPolicyEnforcement.hasEnforcedPolicies;

helper context CyprIoT!Policy def : collectRuleTriggerFromPolicy() : Sequence(CyprIoT!RuleTrigger) =
	self.hasRules->select(r | r.oclIsTypeOf(CyprIoT!RuleTrigger))
;

helper context CyprIoT!Network def : collectEnforcedEnforcedTriggerRulesInNetwork() : Sequence(CyprIoT!RuleTrigger) = 
	self.collectEnforcedPoliciesInNetwork()->collect(p | p.collectRuleTriggerFromPolicy())->flatten()
;

helper def : collectTriggerRulesInMyNetwork() : Sequence(CyprIoT!RuleTrigger) = 
	thisModule.firstNetwork().collectEnforcedEnforcedTriggerRulesInNetwork()
;

helper def : firstRuleInPolicyFromFirstEnforcedPolicy() : CyprIoT!RuleTrigger = 
	thisModule.firstNetwork().collectEnforcedPoliciesInNetwork().first().collectRuleTriggerFromPolicy().first()
	;

helper def : bindOfInputThing() : CyprIoT!Bind = thisModule.firstNetwork().bindsContainingThingInNetwork().first();

helper context CyprIoT!Network def : bindsContainingThingInNetwork() : Sequence(CyprIoT!Bind) = 
	self.hasBinds->select(b | b.isBindMatchesInputThing())
;

rule copyThingMLModel {
	from s : ThingML!ThingMLModel
	to t : ThingML!ThingMLModel(
		configs <- s.configs,
		imports <- s.imports,
		protocols <- s.protocols,
		types <- s.types
	)	
}

rule copyCompositeState {
	from s : ThingML!CompositeState
	using {
		sub : Sequence(ThingML!State) = s.substate->collect(k | thisModule.collectTriggerRulesInMyNetwork()->collect(b | if(not(thisModule.triggerState(b,k).oclIsUndefined().debug('x2'))) then thisModule.triggerState(b,k).debug('x') else s.substate endif)).debug('n')->flatten().debug('f');
	}
	to t : ThingML!CompositeState(
		name <- s.name,
		annotations <- s.annotations,
		entry <- s.entry,
		exit <- s.exit,
		history <- s.history,
		initial <- s.initial,
		internal <- s.internal,
		outgoing <- s.outgoing,
		properties <- s.properties,
		region <- s.region,
		session <- s.session,
		substate <- sub
		)
}

rule copyExternalConnector {
	from s : ThingML!ExternalConnector
	to t : ThingML!ExternalConnector(
		annotations <- s.annotations,
		inst <- s.inst,
		name <- s.name,
		port <- s.port,
		protocol <- s.protocol
	)
}

rule copyThing {
	from s : ThingML!Thing
	to t : ThingML!Thing(
		name <- s.name,
		ports <- s.ports, -- ->collect(k | thisModule.collectTriggerRulesInMyNetwork()->collect(b | if(not(thisModule.triggerRequiredPort(b,k).oclIsUndefined())) then thisModule.triggerRequiredPort(b,k) else s.ports endif))->flatten(),
		annotations <- s.annotations,
		assign <- s.assign,
		behaviour <- s.behaviour,
		fragment <- s.fragment,
		functions <- s.functions,
		messages <- s.messages->union(CyprIoT!RuleTrigger.allInstances()),
		includes <- s.includes,
		properties <- s.properties
	)
}

rule copyProvidedPort {
	from s : ThingML!ProvidedPort
	to t : ThingML!ProvidedPort(
		name <- s.name,
		receives <- s.receives->union(CyprIoT!RuleTrigger.allInstances()),
		sends <- s.sends,
		annotations <- s.annotations
	)
}

rule triggerRequiredPort {
	from k : CyprIoT!RuleTrigger, s : ThingML!RequiredPort
	to t : ThingML!RequiredPort(
		name <- s.name,
		receives <- if(k.isGoToState() and k.isInputThingInRuleTriggerObject()) then s.receives->union(CyprIoT!RuleTrigger.allInstances()) else s.receives endif,
		sends <- if(k.isGoToState() and k.isInputThingInRuleTriggerObject()) then s.sends else s.sends->union(CyprIoT!RuleTrigger.allInstances()) endif,
		annotations <- s.annotations
	)
}

-- done
helper context CyprIoT!RuleTrigger def : isInputThingInRuleTriggerObject() : Boolean = self.effectTrigger.actionTrigger.thingWithState.thing.name=thisModule.bindOfInputThing().bindsInstanceThing.typeThing.thingToInstantiate.name;

-- done
helper context CyprIoT!RuleTrigger def : isInputThingInRuleTriggerSubject() : Boolean = self.thingWithState.thing.name=thisModule.bindOfInputThing().bindsInstanceThing.typeThing.thingToInstantiate.name;

-- done
helper context ThingML!State def : isStateNameEqualToRuleTriggerObjectState(t : CyprIoT!RuleTrigger) : Boolean = self.name=t.effectTrigger.actionTrigger.thingWithState.getState.state.name;

-- done
helper context ThingML!State def : isStateNameEqualToRuleTriggerSubjectState(t : CyprIoT!RuleTrigger) : Boolean = self.name=t.thingWithState.getState.state.name;

-- done
helper context CyprIoT!RuleTrigger def : getFunctionToExecute() : ThingML!Function = ThingML!Function.allInstances()->select(f | f.name=self.effectTrigger.actionTrigger.thingWithFunction.getFunction.function.name).first();

-- done
helper context CyprIoT!RuleTrigger def : isGoToState() : Boolean = not(self.effectTrigger.actionTrigger.goToState.oclIsUndefined());

-- done
helper context CyprIoT!RuleTrigger def : isExecuteFunction() : Boolean = not(self.effectTrigger.actionTrigger.executeFunction.oclIsUndefined());

-- done
helper context CyprIoT!RuleTrigger def : isPerformTransition() : Boolean = not(self.effectTrigger.actionTrigger.performTransition.oclIsUndefined());

-- done
helper context CyprIoT!RuleTrigger def : triggerObjectStateName() : String = self.effectTrigger.actionTrigger.thingWithState.getState.state.name;

-- done
helper context CyprIoT!RuleTrigger def : triggerObjectFunctionName() : String = thisModule.firstRuleInPolicyFromFirstEnforcedPolicy().effectTrigger.actionTrigger.thingWithFunction.getFunction.function.name;


rule triggerMess {
	from s : CyprIoT!RuleTrigger
	to triggerMessage : ThingML!Message(
		name <- if(s.isGoToState()) 
					then s.triggerObjectStateName()
					else if(s.isExecuteFunction()) then s.triggerObjectFunctionName() 
					else 'perfomTransition'
					endif endif
	)	
}

rule copyState {
	from s : ThingML!State(not (s.oclIsTypeOf(ThingML!CompositeState) or s.oclIsTypeOf(ThingML!FinalState)))
	to t : ThingML!State(
		annotations <- s.annotations,
		entry <- s.entry,
		exit <- s.exit,
		internal <- s.internal,
		name <- s.name,
		outgoing <- s.outgoing,
		properties <- s.properties
	)
}


lazy rule triggerState {
	from k : CyprIoT!RuleTrigger , s : ThingML!State( not(s.oclIsTypeOf(ThingML!CompositeState) or s.oclIsTypeOf(ThingML!FinalState)))
	to 
	t : ThingML!State(
		annotations <- s.annotations,
		entry <- if(k.isInputThingInRuleTriggerSubject() and s.isStateNameEqualToRuleTriggerSubjectState(k)) 
					then thisModule.groupActionOnEntry(s) else s.entry endif,
		exit <- s.exit,
		internal <- if(k.isExecuteFunction() and not(k.isInputThingInRuleTriggerSubject())) 
							then s.internal->union(Sequence{transitionInternal}) else s.internal endif,
		name <- s.name,
		outgoing <- if(k.isGoToState() and 
						k.isInputThingInRuleTriggerObject() and 
						not(s.isStateNameEqualToRuleTriggerObjectState(k)))
							then s.outgoing->union(Sequence{transition})
						else if(k.isPerformTransition() and not(k.isInputThingInRuleTriggerSubject())) then
						s.outgoing->union(if(ThingML!Transition.allInstances()->select(i | s.name=i.refImmediateComposite().oclAsType(ThingML!State).name)->collect(a | thisModule.multipleTransition(a)).asOrderedSet().size()>0 and k.effectTrigger.actionTrigger.transitionRank=0) 
							then 
							Sequence{ThingML!Transition.allInstances()->select(i | s.name=i.refImmediateComposite().oclAsType(ThingML!State).name)->collect(a | thisModule.multipleTransition(a)).asOrderedSet().at(1)} 
							else if(ThingML!Transition.allInstances()->select(i | s.name=i.refImmediateComposite().oclAsType(ThingML!State).name)->collect(a | thisModule.multipleTransition(a)).asOrderedSet().size()>0 and not(k.effectTrigger.actionTrigger.transitionRank=0) and ThingML!Transition.allInstances()->select(i | s.name=i.refImmediateComposite().oclAsType(ThingML!State).name)->collect(a | thisModule.multipleTransition(a)).asOrderedSet().size()<=k.effectTrigger.actionTrigger.transitionRank) 
							then 
							Sequence{ThingML!Transition.allInstances()->select(i | s.name=i.refImmediateComposite().oclAsType(ThingML!State).name)->collect(a | thisModule.multipleTransition(a)).asOrderedSet().at(k.effectTrigger.actionTrigger.transitionRank)} 
							else Sequence{} endif endif
						)
						else s.outgoing endif endif,
		properties <- s.properties
	),
	transition : ThingML!Transition(
		target <- if(k.isGoToState() and k.isInputThingInRuleTriggerObject()) then ThingML!State.allInstances()->select(t | t.isStateNameEqualToRuleTriggerObjectState(k)).first() else ThingML!State.allInstances().first() endif,
		event <- receive
	),
	receive : ThingML!ReceiveMessage(
		port <- ThingML!Thing.allInstances().first().ports.first(),
		message <- thisModule.resolveTemp(CyprIoT!RuleTrigger.allInstances().first(), 'triggerMessage'),
		name <- 'trigger'
	),
	receive2 : ThingML!ReceiveMessage(
		port <- ThingML!Thing.allInstances().first().ports.first(),
		message <- thisModule.resolveTemp(CyprIoT!RuleTrigger.allInstances().first(), 'triggerMessage'),
		name <- 'trigger'
	),
	transitionInternal : ThingML!InternalTransition(
		event <- receive2,
		action <- action
	),
	action : ThingML!FunctionCallStatement(
		function <- if(not(k.isInputThingInRuleTriggerSubject()) and k.isExecuteFunction()) then k.getFunctionToExecute() else OclUndefined endif,
		parameters <- if(k.isExecuteFunction() and not(k.effectTrigger.actionTrigger.thingWithFunction.getFunction.parameters.oclIsUndefined())) then k.effectTrigger.actionTrigger.thingWithFunction.getFunction.parameters->collect( p | thisModule.multipleParameters(p))
						else Sequence{} endif
	)	
}

lazy rule multipleParameters {
	from s: String
	to 
	expression : ThingML!IntegerLiteral(
		intValue <- s.toInteger().refInvokeOperation('longValue', Sequence{}) -- bug : use of reflexivity to convert integer to long 
	)
}

lazy rule multipleTransition {
	from s: ThingML!Transition
	to 
	performTransition : ThingML!Transition(
		target <- s.target,
		event <- receive
	),
	receive : ThingML!ReceiveMessage(
		port <- ThingML!Thing.allInstances().first().ports.first(),
		message <- thisModule.resolveTemp(CyprIoT!RuleTrigger.allInstances().first(), 'triggerMessage'),
		name <- 'trigger'
	)
}

lazy rule groupActionOnEntry {
	from s : ThingML!State
	to 
	groupAction : ThingML!ActionBlock(
		actions <- if(not(s.entry.oclIsUndefined())) then Sequence{action,s.entry} else Sequence{action} endif
	),
	action : ThingML!SendAction(
		message <- thisModule.resolveTemp(CyprIoT!RuleTrigger.allInstances().first(), 'triggerMessage'),
		port <- ThingML!Port.allInstances().first()
	)
	
}

