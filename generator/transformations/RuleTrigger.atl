-- @atlcompiler emftvm
-- @nsURI ThingML=http://www.thingml.org/xtext/ThingML
-- @nsURI CyprIoT=http://www.atlanmod.org/CyprIoT


module RuleTrigger;

create OUT: ThingML from TH: ThingML, CY : CyprIoT;

uses Copier;
uses Helpers;

-- Get the network to make (support for first network only for the moment)
helper def : firstNetwork() : CyprIoT!Network = CyprIoT!Network.allInstances().first();

helper context CyprIoT!Network def : collectEnforcedPoliciesInNetwork() : Sequence(CyprIoT!Policy) = self.hasPolicyEnforcement.hasEnforcedPolicies;

helper context CyprIoT!Policy def : collectRuleTriggerFromPolicy() : Sequence(CyprIoT!RuleTrigger) =
	self.hasRules->select(r | r.oclIsTypeOf(CyprIoT!RuleTrigger))
;

helper def : firstRuleInPolicyFromFirstEnforcedPolicy() : CyprIoT!RuleTrigger = 
	thisModule.firstNetwork().collectEnforcedPoliciesInNetwork().first().collectRuleTriggerFromPolicy().first()
	;

helper def : bindOfInputThing() : CyprIoT!Bind = thisModule.firstNetwork().bindsContainingThingInNetwork().first();

helper context CyprIoT!Network def : bindsContainingThingInNetwork() : Sequence(CyprIoT!Bind) = 
	self.hasBinds->select(b | b.isBindMatchesInputThing())
;

rule copyThingMLModel {
	from s : ThingML!ThingMLModel
	to t : ThingML!ThingMLModel(
		configs <- s.configs,
		imports <- s.imports,
		protocols <- s.protocols,
		types <- s.types
	)	
}


rule copyCompositeState {
	from s : ThingML!CompositeState
	to t : ThingML!CompositeState(
		name <- s.name,
		annotations <- s.annotations,
		entry <- s.entry,
		exit <- s.exit,
		history <- s.history,
		initial <- s.initial,
		internal <- s.internal,
		outgoing <- s.outgoing,
		properties <- s.properties,
		region <- s.region,
		session <- s.session,
		substate <- s.substate
	)
}

rule copyExternalConnector {
	from s : ThingML!ExternalConnector
	to t : ThingML!ExternalConnector(
		annotations <- s.annotations,
		inst <- s.inst,
		name <- s.name,
		port <- s.port,
		protocol <- s.protocol
	)
}

rule copyThing {
	from s : ThingML!Thing
	to t : ThingML!Thing(
		name <- s.name,
		ports <- s.ports,
		annotations <- s.annotations,
		assign <- s.assign,
		behaviour <- s.behaviour,
		fragment <- s.fragment,
		functions <- s.functions,
		messages <- s.messages->union(CyprIoT!RuleTrigger.allInstances()),
		includes <- s.includes,
		properties <- s.properties
	)
}

rule copyProvidedPort {
	from s : ThingML!ProvidedPort
	to t : ThingML!ProvidedPort(
		name <- s.name,
		receives <- s.receives->union(CyprIoT!RuleTrigger.allInstances()),
		sends <- s.sends,
		annotations <- s.annotations
	)
}

rule copyRequiredPort {
	from s : ThingML!RequiredPort
	to t : ThingML!RequiredPort(
		name <- s.name,
		receives <- if(thisModule.isGoToState() and thisModule.isInputThingInRuleTriggerObject()) then s.receives->union(CyprIoT!RuleTrigger.allInstances()) else s.receives endif,
		sends <- if(thisModule.isGoToState() and thisModule.isInputThingInRuleTriggerObject()) then s.sends else s.sends->union(CyprIoT!RuleTrigger.allInstances()) endif,
		annotations <- s.annotations
	)
}


helper def : isInputThingInRuleTriggerObject() : Boolean = thisModule.firstRuleInPolicyFromFirstEnforcedPolicy().effectTrigger.actionTrigger.thingWithState.thing.name=thisModule.bindOfInputThing().bindsInstanceThing.typeThing.thingToInstantiate.name;

helper def : isInputThingInRuleTriggerSubject() : Boolean = thisModule.firstRuleInPolicyFromFirstEnforcedPolicy().thingWithState.thing.name=thisModule.bindOfInputThing().bindsInstanceThing.typeThing.thingToInstantiate.name;


helper context ThingML!State def : isStateNameEqualToRuleTriggerObjectState() : Boolean = self.name=thisModule.firstRuleInPolicyFromFirstEnforcedPolicy().effectTrigger.actionTrigger.thingWithState.getState.state.name;

helper context ThingML!State def : isStateNameEqualToRuleTriggerSubjectState() : Boolean = self.name=thisModule.firstRuleInPolicyFromFirstEnforcedPolicy().thingWithState.getState.state.name;

helper def : getFunctionToExecute() : ThingML!Function = ThingML!Function.allInstances()->select(f | f.name=thisModule.firstRuleInPolicyFromFirstEnforcedPolicy().effectTrigger.actionTrigger.thingWithFunction.getFunction.function.name).first();

helper def : isGoToState() : Boolean = not(thisModule.firstRuleInPolicyFromFirstEnforcedPolicy().effectTrigger.actionTrigger.goToState.oclIsUndefined());

helper def : isExecuteFunction() : Boolean = not(thisModule.firstRuleInPolicyFromFirstEnforcedPolicy().effectTrigger.actionTrigger.executeFunction.oclIsUndefined());

helper def : isPerformTransition() : Boolean = not(thisModule.firstRuleInPolicyFromFirstEnforcedPolicy().effectTrigger.actionTrigger.performTransition.oclIsUndefined());

helper def : triggerObjectStateName() : String = thisModule.firstRuleInPolicyFromFirstEnforcedPolicy().effectTrigger.actionTrigger.thingWithState.getState.state.name;

helper def : triggerObjectFunctionName() : String = thisModule.firstRuleInPolicyFromFirstEnforcedPolicy().effectTrigger.actionTrigger.thingWithFunction.getFunction.function.name;


rule triggerMess {
	from s : CyprIoT!RuleTrigger
	to triggerMessage : ThingML!Message(
		name <- if(thisModule.isGoToState()) 
					then thisModule.triggerObjectStateName()
					else if(thisModule.isExecuteFunction()) then thisModule.triggerObjectFunctionName() 
					else 'perfomTransition'
					endif endif
	)	
}

rule copyState {
	from s : ThingML!State( not(s.oclIsTypeOf(ThingML!CompositeState) or s.oclIsTypeOf(ThingML!FinalState)))
	to 
	t : ThingML!State(
		annotations <- s.annotations,
		entry <- if(thisModule.isInputThingInRuleTriggerSubject() and s.isStateNameEqualToRuleTriggerSubjectState()) then thisModule.groupActionOnEntry(s) else s.entry endif,
		exit <- s.exit,
		internal <- if(thisModule.isExecuteFunction() and not(thisModule.isInputThingInRuleTriggerSubject())) 
							then s.internal->union(Sequence{transitionInternal}) else s.internal endif,
		name <- s.name,
		outgoing <- if(thisModule.isGoToState() and 
						thisModule.isInputThingInRuleTriggerObject() and 
						not(s.isStateNameEqualToRuleTriggerObjectState()))
							then s.outgoing->union(Sequence{transition})
						else if(thisModule.isPerformTransition() and not(thisModule.isInputThingInRuleTriggerSubject())) then
						s.outgoing->union(if(ThingML!Transition.allInstances()->select(i | s.name=i.refImmediateComposite().oclAsType(ThingML!State).name)->collect(a | thisModule.multipleTransition(a)).asOrderedSet().size()>0 and thisModule.firstRuleInPolicyFromFirstEnforcedPolicy().effectTrigger.actionTrigger.transitionRank=0) 
							then 
							Sequence{ThingML!Transition.allInstances()->select(i | s.name=i.refImmediateComposite().oclAsType(ThingML!State).name)->collect(a | thisModule.multipleTransition(a)).asOrderedSet().at(1)} 
							else if(ThingML!Transition.allInstances()->select(i | s.name=i.refImmediateComposite().oclAsType(ThingML!State).name)->collect(a | thisModule.multipleTransition(a)).asOrderedSet().size()>0 and not(thisModule.firstRuleInPolicyFromFirstEnforcedPolicy().effectTrigger.actionTrigger.transitionRank=0) and ThingML!Transition.allInstances()->select(i | s.name=i.refImmediateComposite().oclAsType(ThingML!State).name)->collect(a | thisModule.multipleTransition(a)).asOrderedSet().size()<=thisModule.firstRuleInPolicyFromFirstEnforcedPolicy().effectTrigger.actionTrigger.transitionRank) 
							then 
							Sequence{ThingML!Transition.allInstances()->select(i | s.name=i.refImmediateComposite().oclAsType(ThingML!State).name)->collect(a | thisModule.multipleTransition(a)).asOrderedSet().at(thisModule.firstRuleInPolicyFromFirstEnforcedPolicy().effectTrigger.actionTrigger.transitionRank)} 
							else Sequence{} endif endif
						)
						else s.outgoing endif endif,
		properties <- s.properties
	),
	transition : ThingML!Transition(
		target <- if(thisModule.isGoToState() and thisModule.isInputThingInRuleTriggerObject()) then ThingML!State.allInstances()->select(t | t.isStateNameEqualToRuleTriggerObjectState()).first() else ThingML!State.allInstances().first() endif,
		event <- receive
	),
	receive : ThingML!ReceiveMessage(
		port <- ThingML!Thing.allInstances().first().ports.first(),
		message <- thisModule.resolveTemp(CyprIoT!RuleTrigger.allInstances().first(), 'triggerMessage'),
		name <- 'trigger'
	),
	receive2 : ThingML!ReceiveMessage(
		port <- ThingML!Thing.allInstances().first().ports.first(),
		message <- thisModule.resolveTemp(CyprIoT!RuleTrigger.allInstances().first(), 'triggerMessage'),
		name <- 'trigger'
	),
	transitionInternal : ThingML!InternalTransition(
		event <- receive2,
		action <- action
	),
	action : ThingML!FunctionCallStatement(
		function <- if(not(thisModule.isInputThingInRuleTriggerSubject()) and thisModule.isExecuteFunction()) then thisModule.getFunctionToExecute() else OclUndefined endif,
		parameters <- if(thisModule.isExecuteFunction() and thisModule.firstRuleInPolicyFromFirstEnforcedPolicy().effectTrigger.actionTrigger.thingWithFunction.getFunction.parameters.oclIsUndefined()) then OclUndefined
						else thisModule.firstRuleInPolicyFromFirstEnforcedPolicy().effectTrigger.actionTrigger.thingWithFunction.getFunction.parameters->collect( p | thisModule.multipleParameters(p)) endif
	)	
}

lazy rule multipleParameters {
	from s: String
	to 
	expression : ThingML!IntegerLiteral(
		intValue <- s.toInteger().refInvokeOperation('longValue', Sequence{}) -- bug : use of reflexivity to convert integer to long 
	)
}

lazy rule multipleTransition {
	from s: ThingML!Transition
	to 
	performTransition : ThingML!Transition(
		target <- s.target,
		event <- receive
	),
	receive : ThingML!ReceiveMessage(
		port <- ThingML!Thing.allInstances().first().ports.first(),
		message <- thisModule.resolveTemp(CyprIoT!RuleTrigger.allInstances().first(), 'triggerMessage'),
		name <- 'trigger'
	)
}

lazy rule groupActionOnEntry {
	from s : ThingML!State
	to 
	groupAction : ThingML!ActionBlock(
		actions <- if(not(s.entry.oclIsUndefined())) then Sequence{action,s.entry} else Sequence{action} endif
	),
	action : ThingML!SendAction(
		message <- thisModule.resolveTemp(CyprIoT!RuleTrigger.allInstances().first(), 'triggerMessage'),
		port <- ThingML!Port.allInstances().first()
	)
	
}

