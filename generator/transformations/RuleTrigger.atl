-- @atlcompiler emftvm
-- @nsURI ThingML=http://www.thingml.org/xtext/ThingML
-- @nsURI CyprIoT=http://www.atlanmod.org/CyprIoT


module RuleTrigger;

create OUT: ThingML from TH: ThingML, CY : CyprIoT;

uses Copier;
uses Helpers;

-- Get the network to make (support for first network only for the moment)
helper def : firstNetwork() : CyprIoT!Network = CyprIoT!Network.allInstances().first();

helper context CyprIoT!Network def : collectEnforcedPoliciesInNetwork() : Sequence(CyprIoT!Policy) = self.hasPolicyEnforcement.hasEnforcedPolicies;

helper context CyprIoT!Policy def : collectRuleTriggerFromPolicy() : Sequence(CyprIoT!RuleTrigger) =
	self.hasRules->select(r | r.oclIsTypeOf(CyprIoT!RuleTrigger))
;

helper def : firstRuleInPolicyFromFirstEnforcedPolicy() : CyprIoT!RuleTrigger = 
	thisModule.firstNetwork().collectEnforcedPoliciesInNetwork().first().collectRuleTriggerFromPolicy().first()
	;

helper def : bindOfInputThing() : CyprIoT!Bind = thisModule.firstNetwork().bindsContainingThingInNetwork().first();

helper context CyprIoT!Network def : bindsContainingThingInNetwork() : Sequence(CyprIoT!Bind) = 
	self.hasBinds->select(b | b.isBindMatchesInputThing())
;

rule copyThingMLModel {
	from s : ThingML!ThingMLModel
	to t : ThingML!ThingMLModel(
		configs <- s.configs,
		imports <- s.imports,
		protocols <- s.protocols,
		types <- s.types
	)	
}

rule copyExternalConnector {
	from s : ThingML!ExternalConnector
	to t : ThingML!ExternalConnector(
		annotations <- s.annotations,
		inst <- s.inst,
		name <- s.name,
		port <- s.port,
		protocol <- s.protocol
	)
}

rule copyThing {
	from s : ThingML!Thing
	to t : ThingML!Thing(
		name <- s.name,
		ports <- s.ports,
		annotations <- s.annotations,
		assign <- s.assign,
		behaviour <- s.behaviour,
		fragment <- s.fragment,
		functions <- s.functions,
		messages <- s.messages->union(CyprIoT!RuleTrigger.allInstances()),
		includes <- s.includes,
		properties <- s.properties
	)
}

rule copyProvidedPort {
	from s : ThingML!ProvidedPort
	to t : ThingML!ProvidedPort(
		name <- s.name,
		receives <- s.receives->union(CyprIoT!RuleTrigger.allInstances()),
		sends <- s.sends,
		annotations <- s.annotations
	)
}

rule copyRequiredPort {
	from s : ThingML!RequiredPort
	to t : ThingML!RequiredPort(
		name <- s.name,
		receives <- if(thisModule.isGoToState() and thisModule.isInputThingInRuleTriggerObject()) then s.receives->union(CyprIoT!RuleTrigger.allInstances()) else s.receives endif,
		sends <- if(thisModule.isGoToState() and thisModule.isInputThingInRuleTriggerObject()) then s.sends else s.sends->union(CyprIoT!RuleTrigger.allInstances()) endif,
		annotations <- s.annotations
	)
}


helper def : isInputThingInRuleTriggerObject() : Boolean = thisModule.firstRuleInPolicyFromFirstEnforcedPolicy().effectTrigger.actionTrigger.thingWithState.thing.name=thisModule.bindOfInputThing().bindsInstanceThing.typeThing.thingToInstantiate.name;

helper def : isInputThingInRuleTriggerSubject() : Boolean = thisModule.firstRuleInPolicyFromFirstEnforcedPolicy().thingWithState.thing.name=thisModule.bindOfInputThing().bindsInstanceThing.typeThing.thingToInstantiate.name;


helper context ThingML!State def : isStateNameEqualToRuleTriggerObjectState() : Boolean = self.name=thisModule.firstRuleInPolicyFromFirstEnforcedPolicy().effectTrigger.actionTrigger.thingWithState.getState.state.name;

helper context ThingML!State def : isStateNameEqualToRuleTriggerSubjectState() : Boolean = self.name=thisModule.firstRuleInPolicyFromFirstEnforcedPolicy().thingWithState.getState.state.name;

helper def : getFunctionToExecute() : ThingML!Function = ThingML!Function.allInstances()->select(f | f.name=thisModule.firstRuleInPolicyFromFirstEnforcedPolicy().effectTrigger.actionTrigger.thingWithFunction.getFunction.function.name).first();

helper def : isGoToState() : Boolean = not(thisModule.firstRuleInPolicyFromFirstEnforcedPolicy().effectTrigger.actionTrigger.goToState.oclIsUndefined());

helper def : isExecuteFunction() : Boolean = not(thisModule.firstRuleInPolicyFromFirstEnforcedPolicy().effectTrigger.actionTrigger.executeFunction.oclIsUndefined());

rule triggerMess {
	from s : CyprIoT!RuleTrigger
	to triggerMessage : ThingML!Message(
		name <- if(thisModule.isGoToState()) then thisModule.firstRuleInPolicyFromFirstEnforcedPolicy().effectTrigger.actionTrigger.thingWithState.getState.state.name else thisModule.firstRuleInPolicyFromFirstEnforcedPolicy().effectTrigger.actionTrigger.thingWithFunction.getFunction.function.name endif
	)	
}

rule copyState {
	from s : ThingML!State( not(s.oclIsTypeOf(ThingML!CompositeState) or s.oclIsTypeOf(ThingML!FinalState)))
	to 
	t : ThingML!State(
		annotations <- s.annotations,
		entry <- if(thisModule.isInputThingInRuleTriggerSubject() and s.isStateNameEqualToRuleTriggerSubjectState()) then thisModule.groupActionOnEntry(s).debug('2')  else s.entry.debug(s.name) endif,
		exit <- s.exit,
		internal <- if(thisModule.isExecuteFunction() and not(thisModule.isInputThingInRuleTriggerSubject())) 
							then s.internal->union(Sequence{transitionInternal.debug('ecex')}) else s.internal endif,
		name <- s.name,
		outgoing <- if(thisModule.isGoToState() and 
						thisModule.isInputThingInRuleTriggerObject() and 
						not(s.isStateNameEqualToRuleTriggerObjectState()))
					then s.outgoing->union(Sequence{transition})
						else s.outgoing endif,
		properties <- s.properties
	),
	transition : ThingML!Transition(
		target <- if(thisModule.isGoToState() and thisModule.isInputThingInRuleTriggerObject()) then ThingML!State.allInstances()->select(t | t.isStateNameEqualToRuleTriggerObjectState()).first() else ThingML!State.allInstances().first() endif,
		event <- receive
	),
	receive : ThingML!ReceiveMessage(
		port <- ThingML!Thing.allInstances().first().ports.first(),
		message <- thisModule.resolveTemp(CyprIoT!RuleTrigger.allInstances().first(), 'triggerMessage'),
		name <- 'trigger'
	),
	transitionInternal : ThingML!InternalTransition(
		event <- receive,
		action <- action
	),
	action : ThingML!FunctionCallStatement(
		function <- if(not(thisModule.isInputThingInRuleTriggerSubject())) then thisModule.getFunctionToExecute() else OclUndefined endif
	)
}


lazy rule groupActionOnEntry {
	from s : ThingML!State
	to 
	groupAction : ThingML!ActionBlock(
		actions <- if(not(s.entry.oclIsUndefined())) then Sequence{action,s.entry} else Sequence{action} endif
	),
	action : ThingML!SendAction(
		message <- thisModule.resolveTemp(CyprIoT!RuleTrigger.allInstances().first(), 'triggerMessage'),
		port <- ThingML!Port.allInstances().first()
	)
	
}

