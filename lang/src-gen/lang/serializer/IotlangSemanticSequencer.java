/*
 * generated by Xtext 2.13.0
 */
package lang.serializer;

import com.google.inject.Inject;
import java.util.Set;
import lang.iotlang.Bind;
import lang.iotlang.Channel;
import lang.iotlang.Domain;
import lang.iotlang.InstanceBus;
import lang.iotlang.InstancePolicy;
import lang.iotlang.InstanceThing;
import lang.iotlang.IoTLangModel;
import lang.iotlang.IotlangPackage;
import lang.iotlang.Message;
import lang.iotlang.NetworkConfiguration;
import lang.iotlang.PlatformAnnotation;
import lang.iotlang.Policy;
import lang.iotlang.Protocol;
import lang.iotlang.Rule;
import lang.iotlang.Thing;
import lang.iotlang.Topic;
import lang.services.IotlangGrammarAccess;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class IotlangSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private IotlangGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == IotlangPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case IotlangPackage.BIND:
				sequence_Bind(context, (Bind) semanticObject); 
				return; 
			case IotlangPackage.CHANNEL:
				sequence_Channel(context, (Channel) semanticObject); 
				return; 
			case IotlangPackage.DOMAIN:
				sequence_Domain(context, (Domain) semanticObject); 
				return; 
			case IotlangPackage.INSTANCE_BUS:
				sequence_InstanceBus(context, (InstanceBus) semanticObject); 
				return; 
			case IotlangPackage.INSTANCE_POLICY:
				sequence_InstancePolicy(context, (InstancePolicy) semanticObject); 
				return; 
			case IotlangPackage.INSTANCE_THING:
				sequence_InstanceThing(context, (InstanceThing) semanticObject); 
				return; 
			case IotlangPackage.IO_TLANG_MODEL:
				sequence_IoTLangModel(context, (IoTLangModel) semanticObject); 
				return; 
			case IotlangPackage.MESSAGE:
				sequence_Message(context, (Message) semanticObject); 
				return; 
			case IotlangPackage.NETWORK_CONFIGURATION:
				sequence_NetworkConfiguration(context, (NetworkConfiguration) semanticObject); 
				return; 
			case IotlangPackage.PLATFORM_ANNOTATION:
				sequence_PlatformAnnotation(context, (PlatformAnnotation) semanticObject); 
				return; 
			case IotlangPackage.POLICY:
				sequence_Policy(context, (Policy) semanticObject); 
				return; 
			case IotlangPackage.PROTOCOL:
				sequence_Protocol(context, (Protocol) semanticObject); 
				return; 
			case IotlangPackage.RULE:
				sequence_Rule(context, (Rule) semanticObject); 
				return; 
			case IotlangPackage.THING:
				sequence_Thing(context, (Thing) semanticObject); 
				return; 
			case IotlangPackage.TOPIC:
				sequence_Topic(context, (Topic) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     Bind returns Bind
	 *
	 * Constraint:
	 *     (
	 *         name=ID? 
	 *         Thinginst=[InstanceThing|ID] 
	 *         (direction='=>' | direction='<=>' | direction='<=') 
	 *         busInst=[InstanceBus|ID] 
	 *         channels+=[Topic|ID] 
	 *         channels+=[Topic|ID]* 
	 *         annotations+=PlatformAnnotation*
	 *     )
	 */
	protected void sequence_Bind(ISerializationContext context, Bind semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Channel returns Channel
	 *
	 * Constraint:
	 *     (name=ID topics+=Topic*)
	 */
	protected void sequence_Channel(ISerializationContext context, Channel semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Domain returns Domain
	 *
	 * Constraint:
	 *     name=STRING_LIT
	 */
	protected void sequence_Domain(ISerializationContext context, Domain semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, IotlangPackage.Literals.DOMAIN__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, IotlangPackage.Literals.DOMAIN__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDomainAccess().getNameSTRING_LITTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     InstanceBus returns InstanceBus
	 *
	 * Constraint:
	 *     (name=ID number+=INT* typeChannel=[Channel|ID] protocol+=[Protocol|ID] annotations+=PlatformAnnotation*)
	 */
	protected void sequence_InstanceBus(ISerializationContext context, InstanceBus semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     InstancePolicy returns InstancePolicy
	 *
	 * Constraint:
	 *     (name=ID typePolicy=[Policy|ID] annotations+=PlatformAnnotation*)
	 */
	protected void sequence_InstancePolicy(ISerializationContext context, InstancePolicy semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     InstanceThing returns InstanceThing
	 *
	 * Constraint:
	 *     (name=ID number+=INT* type=[Thing|ID] annotations+=PlatformAnnotation*)
	 */
	protected void sequence_InstanceThing(ISerializationContext context, InstanceThing semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     IoTLangModel returns IoTLangModel
	 *
	 * Constraint:
	 *     (things+=Thing | policies+=Policy | channels+=Channel | configs+=NetworkConfiguration)+
	 */
	protected void sequence_IoTLangModel(ISerializationContext context, IoTLangModel semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Message returns Message
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_Message(ISerializationContext context, Message semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, IotlangPackage.Literals.MESSAGE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, IotlangPackage.Literals.MESSAGE__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMessageAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     NetworkConfiguration returns NetworkConfiguration
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         annotations+=PlatformAnnotation* 
	 *         (
	 *             domain+=Domain | 
	 *             binds+=Bind | 
	 *             instances+=InstanceThing | 
	 *             instancesBus+=InstanceBus | 
	 *             enforces+=[InstancePolicy|ID] | 
	 *             instPolicies+=InstancePolicy
	 *         )*
	 *     )
	 */
	protected void sequence_NetworkConfiguration(ISerializationContext context, NetworkConfiguration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PlatformAnnotation returns PlatformAnnotation
	 *
	 * Constraint:
	 *     (name=ANNOTATION_ID value=STRING_LIT)
	 */
	protected void sequence_PlatformAnnotation(ISerializationContext context, PlatformAnnotation semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, IotlangPackage.Literals.PLATFORM_ANNOTATION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, IotlangPackage.Literals.PLATFORM_ANNOTATION__NAME));
			if (transientValues.isValueTransient(semanticObject, IotlangPackage.Literals.PLATFORM_ANNOTATION__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, IotlangPackage.Literals.PLATFORM_ANNOTATION__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPlatformAnnotationAccess().getNameANNOTATION_IDTerminalRuleCall_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getPlatformAnnotationAccess().getValueSTRING_LITTerminalRuleCall_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Policy returns Policy
	 *
	 * Constraint:
	 *     (name=ID rules+=Rule*)
	 */
	protected void sequence_Policy(ISerializationContext context, Policy semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Protocol returns Protocol
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_Protocol(ISerializationContext context, Protocol semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, IotlangPackage.Literals.PROTOCOL__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, IotlangPackage.Literals.PROTOCOL__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getProtocolAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Rule returns Rule
	 *
	 * Constraint:
	 *     (name=ID? things=[Thing|ID] (permission='allow' | permission='deny') (action='send' | action='receive') res=[Thing|ID])
	 */
	protected void sequence_Rule(ISerializationContext context, Rule semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Thing returns Thing
	 *
	 * Constraint:
	 *     (name=ID annotations+=PlatformAnnotation*)
	 */
	protected void sequence_Thing(ISerializationContext context, Thing semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Topic returns Topic
	 *
	 * Constraint:
	 *     (name=ID (type='?' | type='!') messages=[Message|ID])
	 */
	protected void sequence_Topic(ISerializationContext context, Topic semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
