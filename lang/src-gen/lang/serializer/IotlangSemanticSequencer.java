/*
 * generated by Xtext 2.13.0
 */
package lang.serializer;

import com.google.inject.Inject;
import java.util.Set;
import lang.iotlang.Bind;
import lang.iotlang.Domain;
import lang.iotlang.InstanceChannel;
import lang.iotlang.InstancePolicy;
import lang.iotlang.InstanceThing;
import lang.iotlang.IoTLangModel;
import lang.iotlang.IotlangPackage;
import lang.iotlang.Message;
import lang.iotlang.NetworkConfiguration;
import lang.iotlang.PlatformAnnotation;
import lang.iotlang.PointToPoint;
import lang.iotlang.Policy;
import lang.iotlang.Port;
import lang.iotlang.Protocol;
import lang.iotlang.PubSub;
import lang.iotlang.Rule;
import lang.iotlang.Thing;
import lang.iotlang.Topic;
import lang.services.IotlangGrammarAccess;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class IotlangSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private IotlangGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == IotlangPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case IotlangPackage.BIND:
				sequence_Bind(context, (Bind) semanticObject); 
				return; 
			case IotlangPackage.DOMAIN:
				sequence_Domain(context, (Domain) semanticObject); 
				return; 
			case IotlangPackage.INSTANCE_CHANNEL:
				sequence_InstanceChannel(context, (InstanceChannel) semanticObject); 
				return; 
			case IotlangPackage.INSTANCE_POLICY:
				sequence_InstancePolicy(context, (InstancePolicy) semanticObject); 
				return; 
			case IotlangPackage.INSTANCE_THING:
				sequence_InstanceThing(context, (InstanceThing) semanticObject); 
				return; 
			case IotlangPackage.IO_TLANG_MODEL:
				sequence_IoTLangModel(context, (IoTLangModel) semanticObject); 
				return; 
			case IotlangPackage.MESSAGE:
				sequence_Message(context, (Message) semanticObject); 
				return; 
			case IotlangPackage.NETWORK_CONFIGURATION:
				sequence_NetworkConfiguration(context, (NetworkConfiguration) semanticObject); 
				return; 
			case IotlangPackage.PLATFORM_ANNOTATION:
				sequence_PlatformAnnotation(context, (PlatformAnnotation) semanticObject); 
				return; 
			case IotlangPackage.POINT_TO_POINT:
				sequence_PointToPoint(context, (PointToPoint) semanticObject); 
				return; 
			case IotlangPackage.POLICY:
				sequence_Policy(context, (Policy) semanticObject); 
				return; 
			case IotlangPackage.PORT:
				sequence_Port(context, (Port) semanticObject); 
				return; 
			case IotlangPackage.PROTOCOL:
				sequence_Protocol(context, (Protocol) semanticObject); 
				return; 
			case IotlangPackage.PUB_SUB:
				sequence_PubSub(context, (PubSub) semanticObject); 
				return; 
			case IotlangPackage.RULE:
				sequence_Rule(context, (Rule) semanticObject); 
				return; 
			case IotlangPackage.THING:
				sequence_Thing(context, (Thing) semanticObject); 
				return; 
			case IotlangPackage.TOPIC:
				sequence_Topic(context, (Topic) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     Bind returns Bind
	 *
	 * Constraint:
	 *     (
	 *         name=ID? 
	 *         thingInstance=[InstanceThing|ID] 
	 *         (direction='=>' | direction='<=>' | direction='<=') 
	 *         channelInstance=[InstanceChannel|ID] 
	 *         topics+=[Topic|ID] 
	 *         topics+=[Topic|ID]* 
	 *         annotations+=PlatformAnnotation*
	 *     )
	 */
	protected void sequence_Bind(ISerializationContext context, Bind semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Domain returns Domain
	 *
	 * Constraint:
	 *     name=STRING_LIT
	 */
	protected void sequence_Domain(ISerializationContext context, Domain semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, IotlangPackage.Literals.DOMAIN__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, IotlangPackage.Literals.DOMAIN__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDomainAccess().getNameSTRING_LITTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     InstanceChannel returns InstanceChannel
	 *
	 * Constraint:
	 *     (name=ID number+=INT* typeChannel=[Channel|ID] overProtocol=[Protocol|ID] annotations+=PlatformAnnotation*)
	 */
	protected void sequence_InstanceChannel(ISerializationContext context, InstanceChannel semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     InstancePolicy returns InstancePolicy
	 *
	 * Constraint:
	 *     (name=ID typePolicy=[Policy|ID] annotations+=PlatformAnnotation*)
	 */
	protected void sequence_InstancePolicy(ISerializationContext context, InstancePolicy semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     InstanceThing returns InstanceThing
	 *
	 * Constraint:
	 *     (name=ID number+=INT* typeThing=[Thing|ID] annotations+=PlatformAnnotation*)
	 */
	protected void sequence_InstanceThing(ISerializationContext context, InstanceThing semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     IoTLangModel returns IoTLangModel
	 *
	 * Constraint:
	 *     (
	 *         things+=Thing | 
	 *         policies+=Policy | 
	 *         messages+=Message | 
	 *         channels+=Channel | 
	 *         protocols+=Protocol | 
	 *         configs+=NetworkConfiguration
	 *     )+
	 */
	protected void sequence_IoTLangModel(ISerializationContext context, IoTLangModel semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Message returns Message
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_Message(ISerializationContext context, Message semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, IotlangPackage.Literals.MESSAGE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, IotlangPackage.Literals.MESSAGE__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMessageAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     NetworkConfiguration returns NetworkConfiguration
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         annotations+=PlatformAnnotation* 
	 *         (
	 *             domain+=Domain | 
	 *             binds+=Bind | 
	 *             thingInstances+=InstanceThing | 
	 *             channelInstances+=InstanceChannel | 
	 *             enforces+=[InstancePolicy|ID] | 
	 *             instancePoliciy+=InstancePolicy
	 *         )*
	 *     )
	 */
	protected void sequence_NetworkConfiguration(ISerializationContext context, NetworkConfiguration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PlatformAnnotation returns PlatformAnnotation
	 *
	 * Constraint:
	 *     (name=ANNOTATION_ID value=STRING_LIT)
	 */
	protected void sequence_PlatformAnnotation(ISerializationContext context, PlatformAnnotation semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, IotlangPackage.Literals.PLATFORM_ANNOTATION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, IotlangPackage.Literals.PLATFORM_ANNOTATION__NAME));
			if (transientValues.isValueTransient(semanticObject, IotlangPackage.Literals.PLATFORM_ANNOTATION__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, IotlangPackage.Literals.PLATFORM_ANNOTATION__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPlatformAnnotationAccess().getNameANNOTATION_IDTerminalRuleCall_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getPlatformAnnotationAccess().getValueSTRING_LITTerminalRuleCall_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Channel returns PointToPoint
	 *     PointToPoint returns PointToPoint
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_PointToPoint(ISerializationContext context, PointToPoint semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, IotlangPackage.Literals.CHANNEL__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, IotlangPackage.Literals.CHANNEL__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPointToPointAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Policy returns Policy
	 *
	 * Constraint:
	 *     (name=ID hasRules+=Rule*)
	 */
	protected void sequence_Policy(ISerializationContext context, Policy semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Port returns Port
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_Port(ISerializationContext context, Port semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, IotlangPackage.Literals.PORT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, IotlangPackage.Literals.PORT__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPortAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Protocol returns Protocol
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_Protocol(ISerializationContext context, Protocol semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, IotlangPackage.Literals.PROTOCOL__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, IotlangPackage.Literals.PROTOCOL__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getProtocolAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Channel returns PubSub
	 *     PubSub returns PubSub
	 *
	 * Constraint:
	 *     (name=ID hasTopics+=Topic*)
	 */
	protected void sequence_PubSub(ISerializationContext context, PubSub semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Rule returns Rule
	 *
	 * Constraint:
	 *     (
	 *         name=ID? 
	 *         subject=[Thing|ID] 
	 *         (permission='allow' | permission='deny') 
	 *         (action='send' | action='receive') 
	 *         ((object=[Thing|ID] ports+=[Port|ID]*) | objectMessage=[Message|ID])
	 *     )
	 */
	protected void sequence_Rule(ISerializationContext context, Rule semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Thing returns Thing
	 *
	 * Constraint:
	 *     (name=ID annotations+=PlatformAnnotation* ports+=Port)
	 */
	protected void sequence_Thing(ISerializationContext context, Thing semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Topic returns Topic
	 *
	 * Constraint:
	 *     (name=ID acceptedMessages=[Message|ID])
	 */
	protected void sequence_Topic(ISerializationContext context, Topic semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, IotlangPackage.Literals.TOPIC__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, IotlangPackage.Literals.TOPIC__NAME));
			if (transientValues.isValueTransient(semanticObject, IotlangPackage.Literals.TOPIC__ACCEPTED_MESSAGES) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, IotlangPackage.Literals.TOPIC__ACCEPTED_MESSAGES));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTopicAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getTopicAccess().getAcceptedMessagesMessageIDTerminalRuleCall_3_0_1(), semanticObject.eGet(IotlangPackage.Literals.TOPIC__ACCEPTED_MESSAGES, false));
		feeder.finish();
	}
	
	
}
