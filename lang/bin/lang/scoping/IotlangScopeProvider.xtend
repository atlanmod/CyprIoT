/*
 * generated by Xtext 2.13.0
 */
package lang.scoping

import lang.iotlang.IotlangPackage
import java.util.ArrayList
import org.eclipse.emf.ecore.EReference
import org.eclipse.emf.ecore.EObject
import org.eclipse.emf.ecore.ENamedElement
import org.eclipse.xtext.scoping.Scopes
import org.eclipse.xtext.scoping.IScope
import lang.util.Helpers
import lang.iotlang.Port

/**
 * This class contains custom scoping description.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#scoping
 * on how and when to use it.
 */
class IotlangScopeProvider extends AbstractIotlangScopeProvider {
	private val iotlangInstance = IotlangPackage.eINSTANCE;
	protected ArrayList EMPTY = new ArrayList();
	
	override getScope(EObject context, EReference reference) {
		
		if (reference==iotlangInstance.rule_Subject) {
			return Scopes.scopeFor( Helpers.allThings(Helpers.findContainingModel(context)) );
		}else if (reference == iotlangInstance.rule_Object) {
			return Scopes.scopeFor( Helpers.allThings(Helpers.findContainingModel(context)) );
		}else if (reference == iotlangInstance.instanceThing_TypeThing) {
			return Scopes.scopeFor( Helpers.allThings(Helpers.findContainingModel(context)) );
		}else if (reference == iotlangInstance.instancePolicy_TypePolicy) {
			return Scopes.scopeFor( Helpers.allPolicies(Helpers.findContainingModel(context)) );
		}else if (reference == iotlangInstance.networkConfiguration_Enforces) {
			return Scopes.scopeFor( Helpers.allConfigs(Helpers.findContainingModel(context)).get(0).instancePoliciy);
		}else if (reference == iotlangInstance.instanceChannel_TypeChannel) {
			return Scopes.scopeFor( Helpers.allBuses(Helpers.findContainingModel(context)) );
		}else if (reference == iotlangInstance.bind_ThingInstance) {
			return Scopes.scopeFor( Helpers.allConfigs(Helpers.findContainingModel(context)).get(0).thingInstances );
		}else if (reference == iotlangInstance.bind_ChannelInstance) {
			return Scopes.scopeFor( Helpers.allConfigs(Helpers.findContainingModel(context)).get(0).channelInstances );
		}else if (reference == iotlangInstance.bind_Topics) {
			return Scopes.scopeFor( Helpers.allTopics(Helpers.findContainingModel(context)) );
		}else if (reference == iotlangInstance.topic_AcceptedMessages) {
			return Scopes.scopeFor( Helpers.allMessages(Helpers.findContainingModel(context)) );
		}else if (reference == iotlangInstance.instanceChannel_OverProtocol) {
			return Scopes.scopeFor( Helpers.allProtocol(Helpers.findContainingModel(context)) );
		}else if (reference == iotlangInstance.rule_Ports) {
			return Scopes.scopeFor( Helpers.allPorts(Helpers.findContainingThing(context as Port)));
		}else {
			System.err.println("INFO: Resolving reference : " + reference.name + " in Class " + (reference.eContainer as ENamedElement).getName);
		}
		return Scopes.scopeFor( EMPTY );
	}
	
	
}
