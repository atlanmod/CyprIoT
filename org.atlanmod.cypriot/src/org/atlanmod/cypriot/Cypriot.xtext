grammar org.atlanmod.cypriot.Cypriot with org.eclipse.xtext.xbase.Xbase

import "http://www.eclipse.org/emf/2002/Ecore" as ecore
import "platform:/resource/org.atlanmod.cypriot/model/ThingML.ecore" as thingml

generate cyprIoT "http://www.atlanmod.org/CyprIoT"

CyprIoTModel returns CyprIoTModel:
		imports+=Import*
		(declareThings+=Thing | 
		declareChannels+=Channel|
		specifyNetworks+=Network |
		declareUsers+=User |
		specifyPolicies+=Policy |
		declareRoles+=Role)*;

Import:
	'import' importURI=STRING 
;

NamedElement:
	User | Role | Thing | Network | Topic | PointToPoint | PubSub |
	InstanceThing | InstancePubSub | InstancePTP | ConnectionPoint | Topic |
	Bind | ChannelProperty | NetworkProperty |  Policy | ToBindPTP | ToBindPubSub | RegularExpression | Rule |
	";" name=ID
;

Role:
	'role' name=ID
;

User :
	'user' name=ID ('assigned' assignedRoles+=[Role] ( "," assignedRoles+=[Role])*)?
;

Thing:
	'thing' name=ID 
		('assigned' assignedRoles+=[Role|ID] ( "," assignedRoles+=[Role])*)?
		'import' importPath=STRING
		(model=Model)?
;

Model:
	'model' modelFile=[thingml::Thing]
;

NetworkProperty:
	'property' name=ID '=' propertyValue=STRING
;

ChannelProperty:
	'property' name=ID '=' propertyValue=STRING
;

// Dynamicity of the configuration

PoliciesEnforcement :
	'enforce' policyName+=[Policy] ( "," policyName+=[Policy])* combiningAlgo=CombiningAlgo
;
enum CombiningAlgo:
	DENY='override-deny' | 
	ALLOW='override-allow'
;

Domain:
	'domain' name=DomainId
;
Network:
	'network' name=ID '{'
		domain=Domain
		(hasPolicyEnforcement=PoliciesEnforcement)?
		(hasNetworkProperty+=NetworkProperty |
		instantiate+=Instance |
		hasBinds+=Bind |
		hasNetworkBridges+=NetworkBridge
		)*
	'}'
;

Instance:
	InstanceThing | InstancePubSub | InstancePTP
;

InstanceThing :
	'instance' name=ID  ('['declareNumberOfInstances=INT']')? ':' thingToInstantiate=[Thing] ('owner' owner=[User])? 'platform' targetedPlatform=Platform
;


InstancePubSub :
	'instance' name=ID ':' pubSubToInstantiate=[PubSub]   'platform' targetedPlatform=PubSubProtocol
;

InstancePTP :
	'instance' name=ID ':' ptPToInstantiate=[PointToPoint]    'platform'  targetedPlatform=PTPProtocol
;

enum Platform:
	POSIX='CPOSIX' | 
	JAVA='JAVA' |
	ARDUINO='ARDUINO' |
	JS='JS' |
	PYTHON='PYTHON'
;

enum PubSubProtocol:
	MQTT='MQTT' | 
	AMQP='AMQP' 
;

enum PTPProtocol:
	HTTP='HTTP' | 
	COAP='COAP' |
	UPNP='UPNP' |
	ZIGBEE='ZIGBEE' |
	ZWAVE='ZWAVE'
;

PointToPoint:
	'channel:ptp' name=ID '{'
		(	hasChannelProperties+=ChannelProperty |
			hasConnectionPoints +=ConnectionPoint
		)*
	'}'
;

Channel:
	PubSub | PointToPoint
;

ConnectionPoint:
	'ConnectionPoint'  name=ID ('(' acceptedMessages+=ID ( "," assignedRoles+=ID)* ')')*
;

PubSub:
	'channel:pubsub' name=ID '{'
		(	hasChannelProperties+=ChannelProperty |
			hasTopics +=Topic
		)*
	'}'
;

Topic:
	'topic'  name=ID ('(' acceptedMessages+=ID ( "," assignedRoles+=ID)* ')')*  ('subtopicOf' subtopicOf+=[Topic])?
;

Bind:
	'bind'	(name=ID ':')? bindsInstanceThing=[InstanceThing]("." portToBind=[thingml::Port])? bindAction=BindAction channelToBind=ChannelToBind
;

enum BindAction:
	READ='<=' |
	WRITE='=>'
;

ChannelToBind:
	ToBindPubSub | ToBindPTP
;

ToBindPubSub:
	 targetedPubSubInstance=[InstancePubSub] '{' topics+=[Topic] ( "," topics+=[Topic])*'}'
;

ToBindPTP:
	targetedPtpInstance=[InstancePTP] '.' (bindsToConnectionPoint=[ConnectionPoint] | filterConnectionPointsUsingRegex=RegularExpression | allConnectionPoints='*')
;

GlobalBridge:
	'bridge' name=ID '{'
		
	'}'
;

NetworkBridge:
	'bridge' bindSubject=[BridgeSubject] 'to' bridgeToChannel=ChannelToBind
;

BridgeSubject:
	Bind | Topic | ConnectionPoint
;

Policy:
	'policy' name=ID '{'
		(hasRules+=Rule)*
	'}'
;

Rule:
	'rule' (name=ID)? ruleSubject=[RuleSubject] ruleEffect=RuleEffect ':' ruleAction=RuleAction (ruleObject=[RuleSubject] | domainObject=DomainObject) (conditions=Conditions)?
;

Conditions:
	'when' conditionExpression=ConditionsExpression
;

ConditionsExpression: OrExpression;

OrExpression returns Expression:
	AndExpression ({OrExpression.lhs=current} "or" rhs=AndExpression)*
;

AndExpression returns Expression:
	ExpressionAttribute ({AndExpression.lhs=current} "and" rhs=ExpressionAttribute)*
;

ExpressionAttribute:
	attribute=[SubjectAndObject]
;

SubjectAndObject:
	RuleSubject | RuleObject
;

ConditionExpression:
	conditionExpression=DomainObject /* | conditionExpression=[RuleObject] */
;

DomainId:
	ValidID (=>'.' ValidID)+
;

DomainObject :
	DomainId  ('.' '*')?
;
	
enum RuleEffect :
	deny='deny' |
	allow='allow' |
	trigger='trigger' |
	bridge='bridge'
;

enum RuleAction:
	send='send' | 
	receive='receive' |
	performTransition='performTransition' | 
	goToState='goToState' | 
	executeFunction='executeFunction' |
	from='from'| 
	to='to'
;

RuleSubject:
	Thing | Role | User
;

RuleObject:
	Thing | Role | User | Channel | Topic | ConnectionPoint
;


RegularExpression:
	OrRegularExpression
;

//OrExpression returns Expression:
//	AndExpression ({OrExpression.lhs=current} "or" rhs=AndExpression)*
//;
//
//AndExpression returns Expression:
//	Equality ({AndExpression.lhs=current} "and" rhs=Equality)*
//;

Equality returns Expression:
	Comparaison (
	( {EqualsExpression.lhs=current} "==" rhs=Comparaison ) |
	( {NotEqualsExpression.lhs=current} "!=" rhs=Comparaison )
	)*	
;

Comparaison returns Expression:
	Addition (
	( {GreaterExpression.lhs=current} ">" rhs=Addition ) |
	( {LowerExpression.lhs=current} "<" rhs=Addition ) |
	( {GreaterOrEqualExpression.lhs=current} ">=" rhs=Addition ) |
	( {LowerOrEqualExpression.lhs=current} "<=" rhs=Addition )
	)*
;

Addition returns Expression:
	Multiplication (
	( {PlusExpression.lhs=current} "+" rhs=Multiplication ) |
	( {MinusExpression.lhs=current} "-" rhs=Multiplication )
	)*	
;

Multiplication returns Expression:
	Primary (
	( {TimesExpression.lhs=current} "*" rhs=Primary ) |
	( {DivExpression.lhs=current} "/" rhs=Primary ) |
	( {ModExpression.lhs=current} "%" rhs=Primary)
	)*	
;

Primary returns Expression:
	{ExpressionGroup} '(' term=ConditionExpression ')' |
	{NotExpression} "not" term=Primary |
	{UnaryMinus} '-' term=Primary |
	AtomicExpression
;

AtomicExpression returns Expression:
	Literal
;

Literal returns Literal:
	ByteLiteral | CharLiteral | IntegerLiteral | StringLiteral | DoubleLiteral | AnyValue
;

AnyValue returns AnyValue:
	anyValue=ID;

ByteLiteral returns ByteLiteral:
	byteValue=BYTE;
	
CharLiteral returns CharLiteral:
	charValue=CHAR;

IntegerLiteral returns IntegerLiteral:
	intValue=INT;
	
DoubleLiteral returns DoubleLiteral:
	doubleValue = FLOAT;
	
StringLiteral returns StringLiteral:
	stringValue=STRING;
	
OrRegularExpression:
	SequenceExpression ({OrRegularExpression.left = current} '+' right=SequenceExpression)*
;

SequenceExpression:
	HighBindExpression ({SequenceExpression.left = current} right = HighBindExpression)*
;

HighBindExpression:
        AtomicRegularExpression ('*'{StarExpression.innerExpression=current} '*'* )?
;

AtomicRegularExpression:
	BracedExpression | Atom
;

BracedExpression:
	'(' innerExpression = RegularExpression ')'
;

Atom:
	value = CHARI
;


//terminal TIME:
//	
//;
//
//terminal LOCATION:
//	
//;

terminal CHARI returns ecore::EChar:
	('a'..'z'|'A'..'Z'|'0'..'9'|'\\0'|'*')
;

@Override
terminal INT returns ecore::EInt: '1';

@Override
terminal WS			: (' '|'\t'|'\r'|'\n')+;
@Override
terminal ANY_OTHER: .;

// Terminals
terminal BYTE returns ecore::EByte: "0x" ('0'..'9'|'a'..'f'|'A'..'F') ('0'..'9'|'a'..'f'|'A'..'F');

terminal CHAR returns ecore::EByte: "'" ('\\0'|'\\t'|'\\n'|'\\r'|' '..'&'|'\\\''|'('..'['|'\\\\'|']'..'~') "'";

terminal FLOAT returns ecore::EDouble :
('0'..'9')+ '.' ('0'..'9')* (('e'|'E') ('+' | '-')? ('0'..'9')+)?
| '.' ('0'..'9')+ (('e'|'E') ('+' | '-')? ('0'..'9')+)?
| ('0'..'9')+ ('e'|'E') ('+' | '-')? ('0'..'9')+;

terminal ANNOTATION_ID:
	"@" ('a'..'z'|'A'..'Z'|'_') ('a'..'z'|'A'..'Z'|'_'|'0'..'9')*; 