grammar org.atlanmod.cypriot.Cypriot with org.eclipse.xtext.xbase.Xbase

import "http://www.eclipse.org/emf/2002/Ecore" as ecore
// TODO import "platform:/resource/org.atlanmod.cypriot/ThingML.ecore" as thingml

generate cyprIoT "http://www.atlanmod.org/CyprIoT"

CyprIoTModel returns CyprIoTModel:
		(importThings+=Thing | 
		channels+=Channel|
		networks+=Network |
		users+=User |
		policies+=Policy |
		roles+=Role)*;

/*NamedElement:
	User | Role | Thing | Network | Topic | PointToPoint | PubSub |
	InstanceThing | InstancePubSub | InstancePTP | Point | Topic |
	BindPubSub | BindPTP |
	";" name=ID
;*/

// Domain Model
Role:
	'role' name=ID
;

User :
	'user' name=ID 'assigned' assignedRoles+=[Role] ( "," assignedRoles+=[Role])*
;
// TODO [thingml::ThingMLModel]
Thing:
	'thing' name=ID 
		('assigned' assignedRoles+=[Role] ( "," assignedRoles+=[Role])*)?
		'import' importPath=STRING_LIT
;

NetworkProperty:
	'property' name=ID '=' propertyValue=STRING_LIT
;

ChannelProperty:
	'property' name=ID '=' propertyValue=STRING_LIT
;

// Dynamicity of the configuration

EnforcePolicy :
	'enforce' policyName+=[Policy] ( "," policyName+=[Policy])*
;

Network:
	'network' name=ID '{'
		(enforcement=EnforcePolicy)?
		(networkProperty+=NetworkProperty |
		instances+=Instance |
		binds+=Bind | 
		channelBridge+=ChannelBridge
		)*
	'}'
;

Instance:
	InstanceThing | InstancePubSub | InstancePTP
;

InstanceThing :
	'instance' typeThing=[Thing] ':' name=ID ('['numberOfInstances=INT']')?  ('owner' owner=[User])? platform=('@posix' | '@java' | '@arduino' | 'javascript')
;

InstancePubSub :
	'instance' typePubSub=[PubSub] ':' name=ID  'platform' platform=('MQTT' | 'AMQP' )
;

InstancePTP :
	'instance' typePtP=[PointToPoint] ':' name=ID  'platform'  platform=('HTTP' | 'COAP' )
;

PointToPoint:
	'channel:ptp' name=ID '{'
		(	channelProperties+=ChannelProperty |
			haspoints +=ConnectionPoint
		)*
	'}'
;

ChannelBridge:
	'bridge' bind=[Bind] 'to' channel=ChannelBinding
;

Channel:
	PubSub | PointToPoint
;

ConnectionPoint:
	'ConnectionPoint'  name=ID ('(' hasParameters+=ID ( "," assignedRoles+=ID)* ')')*
;

PubSub:
	'channel:pubsub' name=ID '{'
		(	channelProperties+=ChannelProperty |
			hasTopics +=Topic
		)*
	'}'
;

Topic:
	'topic'  name=ID  ('subtopicOf' subtopicOf+=[Topic])?
;

// TODO subjectPort=[thingml::Port]
Bind:
	'bind'	(name=ID)? thingInstance=[InstanceThing]"." subjectPort=ID readOrWrite=('=>' |'<=') bindingChannel=ChannelBinding
;
ChannelBinding:
	PubSubBinding | PTPBinding
;
PubSubBinding:
	 pubSubInstance=[InstancePubSub] '{' topics+=[Topic] ( "," topics+=[Topic])*'}'
;

PTPBinding:
	ptpInstance=[InstancePTP] '.' ConnectionPoint=[ConnectionPoint]
;

Policy:
	'policy' name=ID '{'
		(rules+=Rule)*
	'}'
;

Rule:
	'rule' (name=ID)? ruleSubject=[RuleSubject] ruleEffect=RuleEffect action=RuleAction ruleObject=[RuleObject] 'when' ruleConditions=ConditionExpression
;
enum RuleEffect :
	DENY='deny' |
	ALLOW='allow' |
	TRIGGER='trigger'
;

enum RuleAction:
	SEND='send' | 
	RECEIVE='receive' |  
	PERFORMTRANSITION='performTransition' | 
	GOTOSTATE='goToState' | 
	EXECUTEFUNCTION='executeFunction'
;

RuleSubject:
	Thing | Role | User
;

RuleObject:
	Thing | Role | User | Channel | Topic | ConnectionPoint
;

ConditionExpression:
	OrExpression
;

OrExpression returns Expression:
	AndExpression ({OrExpression.lhs=current} "or" rhs=AndExpression)*
;

AndExpression returns Expression:
	Equality ({AndExpression.lhs=current} "and" rhs=Equality)*
;

Equality returns Expression:
	Comparaison (
	( {EqualsExpression.lhs=current} "==" rhs=Comparaison ) |
	( {NotEqualsExpression.lhs=current} "!=" rhs=Comparaison )
	)*	
;

Comparaison returns Expression:
	Addition (
	( {GreaterExpression.lhs=current} ">" rhs=Addition ) |
	( {LowerExpression.lhs=current} "<" rhs=Addition ) |
	( {GreaterOrEqualExpression.lhs=current} ">=" rhs=Addition ) |
	( {LowerOrEqualExpression.lhs=current} "<=" rhs=Addition )
	)*
;

Addition returns Expression:
	Multiplication (
	( {PlusExpression.lhs=current} "+" rhs=Multiplication ) |
	( {MinusExpression.lhs=current} "-" rhs=Multiplication )
	)*	
;

Multiplication returns Expression:
	Primary (
	( {TimesExpression.lhs=current} "*" rhs=Primary ) |
	( {DivExpression.lhs=current} "/" rhs=Primary ) |
	( {ModExpression.lhs=current} "%" rhs=Primary)
	)*	
;

Primary returns Expression:
	{ExpressionGroup} '(' term=ConditionExpression ')' |
	{NotExpression} "not" term=Primary |
	{UnaryMinus} '-' term=Primary |
	AtomicExpression
;

AtomicExpression returns Expression:
	Literal
;

Literal returns Literal:
	ByteLiteral | CharLiteral | IntegerLiteral | StringLiteral | DoubleLiteral | AnyValue
;

AnyValue returns AnyValue:
	anyValue=ID;

ByteLiteral returns ByteLiteral:
	byteValue=BYTE;
	
CharLiteral returns CharLiteral:
	charValue=CHAR;

IntegerLiteral returns IntegerLiteral:
	intValue=INT;
	
DoubleLiteral returns DoubleLiteral:
	doubleValue = FLOAT;
	
StringLiteral returns StringLiteral:
	stringValue=STRING_LIT;
	
// Terminals
terminal BYTE returns ecore::EByte: "0x" ('0'..'9'|'a'..'f'|'A'..'F') ('0'..'9'|'a'..'f'|'A'..'F');

terminal CHAR returns ecore::EByte: "'" ('\\0'|'\\t'|'\\n'|'\\r'|' '..'&'|'\\\''|'('..'['|'\\\\'|']'..'~') "'";

terminal FLOAT returns ecore::EDouble :
('0'..'9')+ '.' ('0'..'9')* (('e'|'E') ('+' | '-')? ('0'..'9')+)?
| '.' ('0'..'9')+ (('e'|'E') ('+' | '-')? ('0'..'9')+)?
| ('0'..'9')+ ('e'|'E') ('+' | '-')? ('0'..'9')+;


@Override 
terminal INT returns ecore::EInt: ('1'..'9')('0'..'9')*;

terminal STRING_LIT	: 
			'"' ( '\\' . /* 'b'|'t'|'n'|'f'|'r'|'u'|'"'|"'"|'\\' */ | !('\\'|'"') )* '"';

terminal ANNOTATION_ID:
	"@" ('a'..'z'|'A'..'Z'|'_') ('a'..'z'|'A'..'Z'|'_'|'0'..'9')*; 